<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Agora Cloud Recording</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- hls.js to handle .m3u8 playback in non-Safari browsers -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    body {
      overflow-y: auto;
    }
    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-x: auto;
    }
    /* Cloud animation styles */
    @keyframes flyCloud {
      0% {
        transform: translateX(-150px);
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      100% {
        transform: translateX(110vw);
        opacity: 0;
      }
    }
    .cloud-animation {
      position: fixed;
      top: 20px;
      left: -150px;
      width: 64px;
      height: 64px;
      pointer-events: none;
      animation: flyCloud 3s linear forwards;
      z-index: 10000;
    }
  </style>
</head>
<body class="bg-gray-900 text-white min-h-screen py-10 px-4">
  <div class="max-w-6xl mx-auto">

    <!-- Button to open the API Credentials popup -->
    <button onclick="toggleAuthPopup()" class="mb-6 bg-gray-600 hover:bg-gray-700 p-2 rounded font-bold">
      Set API Credentials
    </button>

    <div class="grid md:grid-cols-2 gap-6">
      <!-- Recording Control Panel -->
      <div id="leftPanel" class="bg-gray-800 p-6 rounded-lg shadow-lg">
        <h1 class="text-xl font-bold mb-4 text-center">Agora Cloud Recording</h1>
        <p class="text-sm text-gray-400 mb-4">
          <b>Note:</b> Channel name, UID, and S3 credentials are required. For Web Page Recording, URL is also required.
          All other fields will use recommended defaults if left blank.
        </p>
        <div class="space-y-4">
          <!-- Basic fields -->
          <input id="cname" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Channel Name (cname)" />
          <input id="uid" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="UID (Recording UID)" />
          <!-- Moved token input below UID -->
          <input id="token" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Token (optional)"/>
          
          <label class="block mb-2">Recording Mode:</label>
          <select id="modeSelect" class="w-full p-2 rounded bg-gray-700 text-white">
            <option value="composite">Composite</option>
            <option value="individual">Individual</option>
            <option value="web">Web</option>
          </select>

          <!-- Dynamic fields for each mode -->
          <div id="dynamicFields" class="space-y-2"></div>

          <!-- MP4 Checkbox -->
          <div class="flex items-center">
            <input type="checkbox" id="mp4Checkbox" class="mr-2 h-4 w-4" checked />
            <label for="mp4Checkbox" class="text-sm">Include MP4 in recordingFileConfig?</label>
          </div>

          <!-- Buttons to Acquire, Start, Update, Stop -->
          <div class="grid grid-cols-2 gap-2">
            <button id="acquireBtn" class="bg-green-600 hover:bg-green-700 p-2 rounded font-bold">Acquire</button>
            <button id="startBtn" class="bg-blue-600 hover:bg-blue-700 p-2 rounded font-bold">Start</button>
            <button id="updateBtn" class="bg-yellow-600 hover:bg-yellow-700 p-2 rounded font-bold">Update</button>
            <button id="stopBtn" class="bg-red-600 hover:bg-red-700 p-2 rounded font-bold">Stop</button>
          </div>

          <!-- Buttons for Copy Request Bodies -->
          <div class="flex space-x-2">
            <button id="copyStartBodyBtn" onclick="copyStartRequestBody()" class="w-1/2 bg-purple-600 hover:bg-purple-700 p-2 rounded font-bold">
              Copy Start Request Body
            </button>
            <button id="copyUpdateBodyBtn" onclick="copyUpdateRequestBody()" class="w-1/2 bg-purple-600 hover:bg-purple-700 p-2 rounded font-bold">
              Copy Update Request Body
            </button>
          </div>
        </div>
        <!-- Response panel -->
        <pre id="response" class="mt-4 p-2 bg-gray-700 rounded text-sm"></pre>
      </div>

      <!-- Query Panel -->
      <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
        <h1 class="text-xl font-bold mb-4 text-center">Query Recording</h1>
        
        <p class="text-sm text-gray-400 mb-3">
          If you enter Resource ID and SID here, they will also be used for Update and Stop requests if the checkbox below is checked. 
          Otherwise, the system will use the IDs from the previously acquired or started session.
        </p>

        <!-- Resource ID / SID -->
        <input id="resourceId" class="w-full p-2 mb-2 rounded bg-gray-700 text-white" placeholder="Resource ID" />
        <input id="sid" class="w-full p-2 mb-2 rounded bg-gray-700 text-white" placeholder="Session ID (SID)" />
        
        <!-- Checkbox to pick which IDs to use for Update/Stop -->
        <label class="flex items-center mb-2 text-sm">
          <input type="checkbox" id="useManualResSid" class="mr-2 h-4 w-4" />
          Use these values for Update/Stop calls?
        </label>

        <!-- Query button -->
        <button id="queryBtn" class="w-full bg-blue-600 hover:bg-blue-700 p-2 rounded font-bold mb-2">
          Query
        </button>
        
        <!-- Query results -->
        <pre id="queryResult" class="p-2 bg-gray-700 rounded text-sm min-h-[200px]"></pre>
      </div>
    </div>

    <!-- Live Video Section with Editable Public URL and Copy M3U8 link button -->
    <div id="liveVideoSection" class="mt-6">
        <!-- Now the Copy M3U8 link button is placed here, near the URL input -->
        <div class="flex items-center space-x-2 mb-2">
            <input
              type="text"
              id="publicUrlInput"
              class="w-full p-2 rounded bg-gray-700 text-white"
              placeholder="Public URL will appear here (only works with new recorder for m3u8), will update to mp4 after stop"
            />
            <button
              id="copyM3u8LinkBtn"
              class="hidden bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 text-sm rounded"
            >
              Copy
            </button>
          </div>

        <label class="inline-flex items-center">
            <input type="checkbox" id="playLiveVideoCheckbox" class="form-checkbox h-5 w-5 text-blue-600" />
            <span class="ml-2">Play Live Video</span>
        </label>
        <div id="videoPlayerContainer" class="mt-4 hidden">
            <video id="videoPlayer" controls class="w-full" autoplay></video>
        </div>
    </div>

    <!-- Auth Popup -->
    <div id="authPopup" class="hidden fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center">
      <div class="bg-gray-800 p-6 rounded-lg shadow-lg w-full max-w-sm">
        <h2 class="text-lg font-bold mb-2">RESTful API Credentials</h2>
        <p class="text-sm mb-4">Enter your Agora Customer ID and Secret for authentication.</p>
        <input id="customerId" class="w-full p-2 mb-2 rounded bg-gray-700 text-white" placeholder="Customer ID" />
        <input id="customerSecret" class="w-full p-2 mb-4 rounded bg-gray-700 text-white" placeholder="Customer Secret" type="password" />
        <input id="appid" class="w-full p-2 mb-4 rounded bg-gray-700 text-white" placeholder="App ID" />
        <button onclick="onCloseAuth()" class="w-full bg-red-600 hover:bg-red-700 p-2 rounded font-bold">Close</button>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let globalResourceId = "";
    let globalSid = "";
    let globalMode = "composite"; // default

    let queryIntervalId = null;
    let isAutoQueryActive = false;

    let globalFileName = "";
    let lastQueriedFileName = "";
    let hasFoundPlayableUrl = false;
    // We still keep track of the lastQueriedFileName and lastPlayableName:
    let lastPlayableName = "";

    /* ---------------- STORAGE OPTIONS ---------------- */
    const storageOptions = {
      "1": [ // Amazon S3
        { value: "0", text: "US_EAST_1" },
        { value: "1", text: "US_EAST_2" },
        { value: "2", text: "US_WEST_1" },
        { value: "3", text: "US_WEST_2" },
        { value: "4", text: "EU_WEST_1" },
        { value: "5", text: "EU_WEST_2" },
        { value: "6", text: "EU_WEST_3" },
        { value: "7", text: "EU_CENTRAL_1" },
        { value: "8", text: "AP_SOUTHEAST_1" },
        { value: "9", text: "AP_SOUTHEAST_2" },
        { value: "10", text: "AP_NORTHEAST_1" },
        { value: "11", text: "AP_NORTHEAST_2" },
        { value: "12", text: "SA_EAST_1" },
        { value: "13", text: "CA_CENTRAL_1" },
        { value: "14", text: "AP_SOUTH_1" },
        { value: "15", text: "CN_NORTH_1" },
        { value: "16", text: "CN_NORTHWEST_1" },
        { value: "18", text: "AF_SOUTH_1" },
        { value: "19", text: "AP_EAST_1" },
        { value: "20", text: "AP_NORTHEAST_3" },
        { value: "21", text: "EU_NORTH_1" },
        { value: "22", text: "ME_SOUTH_1" },
        { value: "24", text: "AP_SOUTHEAST_3" },
        { value: "25", text: "EU_SOUTH_1" }
      ],
      "2": [ // Alibaba Cloud
        { value: "0", text: "CN_Hangzhou" },
        { value: "1", text: "CN_Shanghai" },
        { value: "2", text: "CN_Qingdao" },
        { value: "3", text: "CN_Beijing" },
        { value: "4", text: "CN_Zhangjiakou" },
        { value: "5", text: "CN_Huhehaote" },
        { value: "6", text: "CN_Shenzhen" },
        { value: "7", text: "CN_Hongkong" },
        { value: "8", text: "US_West_1" },
        { value: "9", text: "US_East_1" },
        { value: "10", text: "AP_Southeast_1" },
        { value: "11", text: "AP_Southeast_2" },
        { value: "12", text: "AP_Southeast_3" },
        { value: "13", text: "AP_Southeast_5" },
        { value: "14", text: "AP_Northeast_1" },
        { value: "15", text: "AP_South_1" },
        { value: "16", text: "EU_Central_1" },
        { value: "17", text: "EU_West_1" },
        { value: "18", text: "EU_East_1" },
        { value: "19", text: "AP_Southeast_6" },
        { value: "20", text: "CN_Heyuan" },
        { value: "21", text: "CN_Guangzhou" },
        { value: "22", text: "CN_Chengdu" },
        { value: "23", text: "CN_Nanjing" },
        { value: "24", text: "CN_Fuzhou" },
        { value: "25", text: "CN_Wulanchabu" },
        { value: "26", text: "CN_Northeast_2" },
        { value: "27", text: "CN_Southeast_7" }
      ],
      "3": [ // Tencent Cloud
        { value: "0", text: "AP_Beijing_1" },
        { value: "1", text: "AP_Beijing" },
        { value: "2", text: "AP_Shanghai" },
        { value: "3", text: "AP_Guangzhou" },
        { value: "4", text: "AP_Chengdu" },
        { value: "5", text: "AP_Chongqing" },
        { value: "6", text: "AP_Shenzhen_FSI" },
        { value: "7", text: "AP_Shanghai_FSI" },
        { value: "8", text: "AP_Beijing_FSI" },
        { value: "9", text: "AP_Hongkong" },
        { value: "10", text: "AP_Singapore" },
        { value: "11", text: "AP_Mumbai" },
        { value: "12", text: "AP_Seoul" },
        { value: "13", text: "AP_Bangkok" },
        { value: "14", text: "AP_Tokyo" },
        { value: "15", text: "NA_Siliconvalley" },
        { value: "16", text: "NA_Ashburn" },
        { value: "17", text: "NA_Toronto" },
        { value: "18", text: "EU_Frankfurt" },
        { value: "19", text: "EU_Moscow" }
      ],
      "5": null, // Microsoft Azure
      "6": null, // Google Cloud
      "7": [ // Huawei Cloud
        { value: "0", text: "CN_North_1" },
        { value: "1", text: "CN_North_4" },
        { value: "2", text: "CN_East_2" },
        { value: "3", text: "CN_East_3" },
        { value: "4", text: "CN_South_1" },
        { value: "5", text: "CN_Southwest_2" },
        { value: "6", text: "AP_Southeast_1" },
        { value: "7", text: "AP_Southeast_2" },
        { value: "8", text: "AP_Southeast_3" },
        { value: "9", text: "AF_South_1" },
        { value: "10", text: "SA_Argentina_1" },
        { value: "11", text: "SA_Peru_1" },
        { value: "12", text: "NA_Mexico_1" },
        { value: "13", text: "SA_Brazil_1" },
        { value: "14", text: "LA_South_2" },
        { value: "15", text: "SA_Chile_1" }
      ],
      "8": [ // Baidu Smart Cloud
        { value: "1", text: "Baoding" },
        { value: "2", text: "Suzhou" },
        { value: "3", text: "Guangzhou" },
        { value: "4", text: "Hongkong" },
        { value: "5", text: "Singapore" },
        { value: "6", text: "Wuhan" },
        { value: "7", text: "Shanghai" }
      ]
    };

    /* ---------------- INIT & CREDENTIALS ---------------- */
    window.onload = () => {
      loadCredentialsFromStorage();
      updateFields();
      // Attach event handlers
      document.getElementById("modeSelect").addEventListener("change", onModeChange);
      document.getElementById("acquireBtn").addEventListener("click", onAcquireClick);
      document.getElementById("startBtn").addEventListener("click", onStartClick);
      document.getElementById("updateBtn").addEventListener("click", onUpdateClick);
      document.getElementById("stopBtn").addEventListener("click", onStopClick);
      document.getElementById("queryBtn").addEventListener("click", onQueryClick);
      attachStopAutoQueryListeners();

      // Play Live Video checkbox
      document.getElementById("playLiveVideoCheckbox").addEventListener("change", function() {
        const container = document.getElementById("videoPlayerContainer");
        if (this.checked) {
          const videoPlayer = document.getElementById("videoPlayer");
          const publicURL = generatePublicURL();
          if (publicURL) {
            handleVideoPlayback(publicURL, videoPlayer);
            container.classList.remove("hidden");
            document.getElementById("publicUrlInput").value = publicURL;
          } else {
            container.classList.remove("hidden");
          }
        } else {
          container.classList.add("hidden");
          document.getElementById("videoPlayer").src = "";
        }
      });

      // Manual URL changes + Enter to play
      document.getElementById("publicUrlInput").addEventListener("keydown", function(e) {
        if (e.key === "Enter") {
          const url = this.value.trim();
          if (!url) return;
          const videoPlayer = document.getElementById("videoPlayer");
          handleVideoPlayback(url, videoPlayer);
          document.getElementById("videoPlayerContainer").classList.remove("hidden");
        }
      });

      // Copy M3U8 link button is hidden until we have an M3U8 to copy
      document.getElementById("copyM3u8LinkBtn").addEventListener("click", () => {
        if (currentM3u8Url) copyToClipboard(currentM3u8Url);
      });
    };

    function toggleAuthPopup() {
      document.getElementById("authPopup").classList.toggle("hidden");
    }

    function onCloseAuth() {
      const cid = document.getElementById("customerId").value.trim();
      const csecret = document.getElementById("customerSecret").value.trim();
      const aid = document.getElementById("appid").value.trim();
      localStorage.setItem("customerId", cid);
      localStorage.setItem("customerSecret", csecret);
      localStorage.setItem("appid", aid);
      toggleAuthPopup();
    }

    function loadCredentialsFromStorage() {
      document.getElementById("customerId").value = localStorage.getItem("customerId") || "";
      document.getElementById("customerSecret").value = localStorage.getItem("customerSecret") || "";
      document.getElementById("appid").value = localStorage.getItem("appid") || "";
    }

    function getAuthHeaders() {
      const customerId = document.getElementById("customerId").value.trim();
      const customerSecret = document.getElementById("customerSecret").value.trim();
      return "Basic " + btoa(customerId + ":" + customerSecret);
    }

    /* ---------------- GET ACTIVE RESOURCE & SID ---------------- */
    function getActiveResourceAndSid() {
      if (document.getElementById("useManualResSid").checked) {
        return {
          resourceId: document.getElementById("resourceId").value.trim(),
          sid: document.getElementById("sid").value.trim()
        };
      } else {
        return { resourceId: globalResourceId, sid: globalSid };
      }
    }

    /* ---------------- MODE & UI ---------------- */
    function onModeChange() {
      stopAutoQuery();
      globalMode = document.getElementById("modeSelect").value;
      updateFields();
    }

    function updateFields() {
      const container = document.getElementById("dynamicFields");
      if (globalMode === "composite") {
        container.innerHTML = getCompositeFieldsHTML();
      } else if (globalMode === "individual") {
        container.innerHTML = getIndividualFieldsHTML();
      } else {
        container.innerHTML = getWebFieldsHTML();
      }
      updateStorageRegion(globalMode); // Re-populate region dropdown
    }

    function getCompositeFieldsHTML() {
      return `
        <p class="text-sm font-semibold">Start Configs (Composite):</p>
        <!-- Using common token input above; no separate composite token -->
        <input id="compositeMaxIdleTime" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Max Idle Time (default=30)"/>
        <label class="block text-sm font-semibold">Stream Types:</label>
        <select id="compositeStreamTypes" class="w-full p-2 rounded bg-gray-700 text-white">
          <option value="0">0: Audio Only</option>
          <option value="1">1: Video Only</option>
          <option value="2" selected>2: Audio + Video (Default)</option>
        </select>
        <p class="text-sm font-semibold mt-2">Audio UIDs (comma-separated):</p>
        <input id="compositeSubscribeAudioUids" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Subscribe Audio UIDs"/>
        <input id="compositeUnsubscribeAudioUids" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Unsubscribe Audio UIDs"/>
        <p class="text-sm font-semibold mt-2">Video UIDs (comma-separated):</p>
        <input id="compositeSubscribeVideoUids" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Subscribe Video UIDs"/>
        <input id="compositeUnsubscribeVideoUids" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Unsubscribe Video UIDs"/>
        <input id="compositeSubscribeUidGroup" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Subscribe UID Group (0 or 1)"/>
        <p class="text-sm font-semibold">Transcoding (for Start):</p>
        <label class="block text-sm font-semibold">Audio Profile:</label>
        <select id="compositeAudioProfile" class="w-full p-2 rounded bg-gray-700 text-white">
          <option value="0">0: 48kHz, mono, ~48 Kbps (Default)</option>
          <option value="1">1: 48kHz, mono, ~128 Kbps</option>
          <option value="2">2: 48kHz, stereo, ~192 Kbps</option>
        </select>
        <label class="block text-sm font-semibold">Channel Type:</label>
        <select id="compositeChannelType" class="w-full p-2 rounded bg-gray-700 text-white">
          <option value="0" selected>0: Communication (Default)</option>
          <option value="1">1: Live Streaming</option>
        </select>
        <label class="block text-sm font-semibold">Video Stream Type:</label>
        <select id="compositeVideoStreamType" class="w-full p-2 rounded bg-gray-700 text-white">
          <option value="0" selected>0: High-Quality (Default)</option>
          <option value="1">1: Low-Quality</option>
        </select>
        <label class="block text-sm font-semibold">Mixed Video Layout:</label>
        <select id="compositeTranscodingLayout" class="w-full p-2 rounded bg-gray-700 text-white">
          <option value="0" selected>0: Floating Layout (Default)</option>
          <option value="1">1: Adaptive Layout</option>
          <option value="2">2: Vertical Layout</option>
          <option value="3">3: Customized Layout</option>
        </select>
        <input id="compositeTranscodingWidth" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Width (default=360)"/>
        <input id="compositeTranscodingHeight" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Height (default=640)"/>
        <input id="compositeTranscodingBitrate" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Bitrate (default=500)"/>
        <input id="compositeTranscodingFps" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="FPS (default=15)"/>
        <p class="text-sm font-semibold">Storage (for Start only):</p>
        <input id="compositeAccessKey" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Storage Access Key"/>
        <input id="compositeSecretKey" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Storage Secret Key"/>
        <input id="compositeBucket" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Storage Bucket"/>
        <label class="block text-sm font-semibold">Vendor:</label>
        <select id="compositeVendor" class="w-full p-2 rounded bg-gray-700 text-white" onchange="updateStorageRegion('composite')">
          <option value="1" selected>Amazon S3</option>
          <option value="2">Alibaba Cloud</option>
          <option value="3">Tencent Cloud</option>
          <option value="5">Microsoft Azure</option>
          <option value="6">Google Cloud</option>
          <option value="7">Huawei Cloud</option>
          <option value="8">Baidu Smart Cloud</option>
        </select>
        <label class="block text-sm font-semibold">Region:</label>
        <select id="compositeRegion" class="w-full p-2 rounded bg-gray-700 text-white"></select>
        <input id="compositeFileNamePrefix" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="File Name Prefix (comma-separated)"/>
        <hr class="border-gray-600 my-2" />
        <p class="text-sm font-semibold">Update (Composite):</p>
        <p class="text-sm">Update will only modify subscribe/unsubscribe UIDs for Audio/Video.</p>
      `;
    }

    function getIndividualFieldsHTML() {
      return `
        <p class="text-sm font-semibold">Start Configs (Individual):</p>
        <!-- Using common token input; no separate individual token -->
        <input id="individualMaxIdleTime" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Max Idle Time (default=30)"/>
        <label class="block text-sm font-semibold">Stream Types:</label>
        <select id="individualStreamTypes" class="w-full p-2 rounded bg-gray-700 text-white">
          <option value="0">0: Audio Only</option>
          <option value="1">1: Video Only</option>
          <option value="2" selected>2: Audio + Video (Default)</option>
        </select>
        <p class="text-sm font-semibold mt-2">Audio UIDs (comma-separated):</p>
        <input id="individualSubscribeAudioUids" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Subscribe Audio UIDs"/>
        <input id="individualUnsubscribeAudioUids" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Unsubscribe Audio UIDs"/>
        <p class="text-sm font-semibold mt-2">Video UIDs (comma-separated):</p>
        <input id="individualSubscribeVideoUids" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Subscribe Video UIDs"/>
        <input id="individualUnsubscribeVideoUids" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Unsubscribe Video UIDs"/>
        <input id="individualSubscribeUidGroup" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Subscribe UID Group (0 or 1)"/>
        <label class="block text-sm font-semibold">Channel Type:</label>
        <select id="individualChannelType" class="w-full p-2 rounded bg-gray-700 text-white">
          <option value="0" selected>0: Communication (Default)</option>
          <option value="1">1: Live Streaming</option>
        </select>
        <label class="block text-sm font-semibold">Video Stream Type:</label>
        <select id="individualVideoStreamType" class="w-full p-2 rounded bg-gray-700 text-white">
          <option value="0" selected>0: High-Quality (Default)</option>
          <option value="1">1: Low-Quality</option>
        </select>
        <p class="text-sm font-semibold">Storage (for Start only):</p>
        <input id="individualAccessKey" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Storage Access Key"/>
        <input id="individualSecretKey" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Storage Secret Key"/>
        <input id="individualBucket" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Storage Bucket"/>
        <label class="block text-sm font-semibold">Vendor:</label>
        <select id="individualVendor" class="w-full p-2 rounded bg-gray-700 text-white" onchange="updateStorageRegion('individual')">
          <option value="1" selected>Amazon S3</option>
          <option value="2">Alibaba Cloud</option>
          <option value="3">Tencent Cloud</option>
          <option value="5">Microsoft Azure</option>
          <option value="6">Google Cloud</option>
          <option value="7">Huawei Cloud</option>
          <option value="8">Baidu Smart Cloud</option>
        </select>
        <label class="block text-sm font-semibold">Region:</label>
        <select id="individualRegion" class="w-full p-2 rounded bg-gray-700 text-white"></select>
        <input id="individualFileNamePrefix" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="File Name Prefix (comma-separated)"/>
        <hr class="border-gray-600 my-2" />
        <p class="text-sm font-semibold">Update (Individual):</p>
        <p class="text-sm">Update will only modify subscribe/unsubscribe UIDs for Audio/Video.</p>
      `;
    }

    function getWebFieldsHTML() {
      return `
        <p class="text-sm font-semibold">Start Configs (Web):</p>
        <!-- Using common token input; no separate web token -->
        <input id="webUrl" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Web URL"/>
        <input id="webMaxRecordingHour" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Max Recording Hour (default=3)"/>
        <p class="text-sm font-semibold">Web Recorder Service Config:</p>
        <label class="block text-sm font-semibold">Audio Profile:</label>
        <select id="webAudioProfile" class="w-full p-2 rounded bg-gray-700 text-white">
          <option value="0" selected>0: 48kHz, mono, ~48 Kbps (Default)</option>
          <option value="1">1: 48kHz, mono, ~128 Kbps</option>
          <option value="2">2: 48kHz, stereo, ~192 Kbps</option>
        </select>
        <input id="webVideoWidth" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Video Width (1280)"/>
        <input id="webVideoHeight" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Video Height (720)"/>
        <p class="text-sm font-semibold">Storage (for Start only):</p>
        <input id="webAccessKey" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Storage Access Key"/>
        <input id="webSecretKey" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Storage Secret Key"/>
        <input id="webBucket" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="Storage Bucket"/>
        <label class="block text-sm font-semibold">Vendor:</label>
        <select id="webVendor" class="w-full p-2 rounded bg-gray-700 text-white" onchange="updateStorageRegion('web')">
          <option value="1" selected>Amazon S3</option>
          <option value="2">Alibaba Cloud</option>
          <option value="3">Tencent Cloud</option>
          <option value="5">Microsoft Azure</option>
          <option value="6">Google Cloud</option>
          <option value="7">Huawei Cloud</option>
          <option value="8">Baidu Smart Cloud</option>
        </select>
        <label class="block text-sm font-semibold">Region:</label>
        <select id="webRegion" class="w-full p-2 rounded bg-gray-700 text-white"></select>
        <input id="webFileNamePrefix" class="w-full p-2 rounded bg-gray-700 text-white" placeholder="File Name Prefix (comma-separated)"/>
        <hr class="border-gray-600 my-2" />
        <p class="text-sm font-semibold">Update (Web):</p>
        <p class="text-sm">Only toggles onHold (true/false).</p>
        <div class="flex items-center">
          <input type="checkbox" id="webOnHoldCheckbox" class="mr-2 h-4 w-4" />
          <label for="webOnHoldCheckbox" class="text-sm">onHold?</label>
        </div>
      `;
    }

    function getUrlMode() {
      return globalMode === "composite" ? "mix" : globalMode;
    }

    function normalizeRegion(regionStr) {
      return regionStr.toLowerCase().replace(/_/g, '-');
    }

    function getRegionText(vendor, regionValue) {
      const regions = storageOptions[vendor.toString()];
      if (!regions) return "";
      for (let opt of regions) {
        if (parseInt(opt.value, 10) === regionValue) {
          return opt.text;
        }
      }
      return "";
    }

    function intVal(id, def) {
      const str = document.getElementById(id)?.value.trim() || "";
      const val = parseInt(str, 10);
      return isNaN(val) ? def : val;
    }

    function arrayVal(id) {
      const str = document.getElementById(id)?.value.trim() || "";
      return str ? str.split(",").map(s => s.trim()).filter(Boolean) : [];
    }

    function attachStopAutoQueryListeners() {
      const leftPanel = document.getElementById("leftPanel");
      leftPanel.addEventListener("input", stopAutoQuery);
      leftPanel.addEventListener("click", stopAutoQuery);
    }

    function updateStorageRegion(mode) {
      const vendorSelect = document.getElementById(mode + "Vendor");
      const regionSelect = document.getElementById(mode + "Region");
      const vendorValue = vendorSelect.value;
      const regions = storageOptions[vendorValue];
      if (!regions) {
        regionSelect.innerHTML = `<option value="">Not required</option>`;
        regionSelect.disabled = true;
      } else {
        regionSelect.disabled = false;
        regionSelect.innerHTML = regions.map(opt => `<option value="${opt.value}">${opt.text}</option>`).join("");
      }
    }

    function getStorageConfigForCurrentMode() {
      let bucket, vendor, region, fileNamePrefix;
      if (globalMode === "composite") {
        bucket = document.getElementById("compositeBucket").value.trim();
        vendor = parseInt(document.getElementById("compositeVendor").value, 10);
        region = parseInt(document.getElementById("compositeRegion").value, 10);
        fileNamePrefix = document.getElementById("compositeFileNamePrefix").value.trim();
      } else if (globalMode === "individual") {
        bucket = document.getElementById("individualBucket").value.trim();
        vendor = parseInt(document.getElementById("individualVendor").value, 10);
        region = parseInt(document.getElementById("individualRegion").value, 10);
        fileNamePrefix = document.getElementById("individualFileNamePrefix").value.trim();
      } else {
        // web
        bucket = document.getElementById("webBucket").value.trim();
        vendor = parseInt(document.getElementById("webVendor").value, 10);
        region = parseInt(document.getElementById("webRegion").value, 10);
        fileNamePrefix = document.getElementById("webFileNamePrefix").value.trim();
      }
      return { bucket, vendor, region, fileNamePrefix };
    }

    /* ---------------- Rename logic for composite + .m3u8 ---------------- */
    function renameM3u8ForComposite(originalName, prefixFilledOut) {
      // If prefix is NOT filled out, rename to "live_name.m3u8"
      // If prefix is filled out, find the last slash and insert "live_" after it
      // Example: "prefix/testfile.m3u8" -> "prefix/live_testfile.m3u8"
      const baseM3u8 = originalName.replace(/\.m3u8$/, ""); // remove .m3u8
      if (!prefixFilledOut) {
        // no prefix: rename entire thing to "live_<basename>.m3u8"
        // e.g. if original is "some/folder/file.m3u8", we just get the last part "file"
        let lastPart = baseM3u8.replace(/^.*\//, ""); // remove path
        return "live_" + lastPart + ".m3u8";
      } else {
        // prefix is set: find the last slash and insert "live_" after it
        const slashIdx = baseM3u8.lastIndexOf("/");
        if (slashIdx === -1) {
          // no slash, just do "live_<filename>.m3u8"
          return "live_" + baseM3u8 + ".m3u8";
        }
        // separate folder path from file
        const folder = baseM3u8.substring(0, slashIdx + 1);
        const file = baseM3u8.substring(slashIdx + 1);
        return folder + "live_" + file + ".m3u8";
      }
    }

    /* ---------------- GENERATE PUBLIC URL ---------------- */
    function generatePublicURL() {
      if (!globalFileName) return "";
      const { bucket, vendor, region } = getStorageConfigForCurrentMode();
      let url = "";
      const regionText = getRegionText(vendor, region);

      switch(vendor) {
        case 1:
          url = `https://${bucket}.s3.${normalizeRegion(regionText)}.amazonaws.com/${globalFileName}`;
          break;
        case 2:
          url = `https://${bucket}.oss-${normalizeRegion(regionText)}.aliyuncs.com/${globalFileName}`;
          break;
        case 3:
          url = `https://${bucket}.cos.${normalizeRegion(regionText)}.myqcloud.com/${globalFileName}`;
          break;
        case 5:
          url = `https://${bucket}.blob.core.windows.net/${globalFileName}`;
          break;
        case 6:
          url = `https://storage.googleapis.com/${bucket}/${globalFileName}`;
          break;
        case 7:
          url = `https://${bucket}.obs.${normalizeRegion(regionText)}.myhuaweicloud.com/${globalFileName}`;
          break;
        case 8:
          url = `https://${bucket}.bcebos.com/${globalFileName}`;
          break;
        default:
          url = "";
      }
      return url;
    }

    /* ---------------- CLOUD ANIMATION ---------------- */
    function animateCloud() {
      const cloud = document.createElement('div');
      cloud.classList.add('cloud-animation');
      cloud.innerHTML = `
    <svg width="400" height="300" viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="cloudGradient" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0%" stop-color="#B3E5FC"/>
          <stop offset="100%" stop-color="#81D4FA"/>
        </linearGradient>
      </defs>
      <g>
        <ellipse cx="150" cy="150" rx="50" ry="35" fill="url(#cloudGradient)" />
        <ellipse cx="210" cy="130" rx="45" ry="30" fill="url(#cloudGradient)" />
        <ellipse cx="270" cy="150" rx="50" ry="35" fill="url(#cloudGradient)" />
        <ellipse cx="210" cy="170" rx="60" ry="40" fill="url(#cloudGradient)" />
        <text x="210" y="155" text-anchor="middle" fill="#fff" font-size="30" font-family="Arial" dy=".3em">
          Agora
        </text>
      </g>
    </svg>
  `;
      document.body.appendChild(cloud);
      cloud.addEventListener('animationend', () => {
        cloud.remove();
      });
    }

    /* ---------------- VIDEO HELPER ---------------- */
    function handleVideoPlayback(url, videoElem) {
      if (url.endsWith(".m3u8")) {
        if (Hls.isSupported()) {
          const hls = new Hls();
          hls.loadSource(url);
          hls.attachMedia(videoElem);
        } else if (videoElem.canPlayType('application/vnd.apple.mpegurl')) {
          videoElem.src = url;
        } else {
          console.warn("This browser does not support M3U8 or HLS.");
        }
      } else {
        // e.g. MP4
        videoElem.src = url;
      }
      videoElem.currentTime = 0;
      videoElem.play();
    }

    /* ---------------- COPY HELPER ---------------- */
    function copyToClipboard(str) {
      navigator.clipboard.writeText(str).then(() => {
        alert("Copied to clipboard!");
      }).catch(err => {
        alert("Failed to copy: " + err);
      });
    }

    let currentM3u8Url = ""; // We'll store the M3U8 link if needed

    /* ---------------- VALIDATION & ACQUIRE ---------------- */
    async function acquireRecording() {
      document.getElementById("queryResult").textContent = "";
      globalSid = "";
      document.getElementById("sid").value = "";
      const responseEl = document.getElementById("response");
      responseEl.textContent = "Acquiring resource...";
      const cname = document.getElementById("cname").value.trim();
      const uid = document.getElementById("uid").value.trim();
      const appid = document.getElementById("appid").value.trim();
      if (!cname || !uid) {
        responseEl.textContent = "Error: Channel name and UID are required.";
        return;
      }
      if (!appid) {
        responseEl.textContent = "Error: App ID is required.";
        return;
      }
      const body = { cname, uid, clientRequest: {} };
      if (globalMode === "web") {
        body.clientRequest.resourceExpiredHour = 24;
        body.clientRequest.scene = 1;
      }
      const url = `https://api.agora.io/v1/apps/${appid}/cloud_recording/acquire`;
      try {
        const resp = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json", "Authorization": getAuthHeaders() },
          body: JSON.stringify(body)
        });
        const data = await resp.json();
        globalResourceId = data.resourceId || "";
        document.getElementById("resourceId").value = globalResourceId;
        responseEl.textContent = JSON.stringify(data, null, 2);
      } catch (error) {
        responseEl.textContent = error.toString();
      }
    }

    /* ---------------- SHOULD INCLUDE MP4? ---------------- */
    function shouldIncludeMp4() {
      return document.getElementById("mp4Checkbox").checked;
    }

    /* ---------------- START ---------------- */
    function buildStartBodyComposite() {
      const cname = document.getElementById("cname").value.trim();
      const uid = document.getElementById("uid").value.trim();
      const token = document.getElementById("token").value.trim();
      const maxIdleTime = intVal("compositeMaxIdleTime", 30);
      const streamTypes = intVal("compositeStreamTypes", 2);
      const subscribeVideoUids = arrayVal("compositeSubscribeVideoUids");
      const unsubscribeVideoUids = arrayVal("compositeUnsubscribeVideoUids");
      const subscribeAudioUids = arrayVal("compositeSubscribeAudioUids");
      const unsubscribeAudioUids = arrayVal("compositeUnsubscribeAudioUids");
      const subscribeUidGroup = intVal("compositeSubscribeUidGroup", 0);
      const audioProfile = intVal("compositeAudioProfile", 0);
      const channelType = intVal("compositeChannelType", 0);
      const videoStreamType = intVal("compositeVideoStreamType", 0);
      const width = intVal("compositeTranscodingWidth", 360);
      const height = intVal("compositeTranscodingHeight", 640);
      const bitrate = intVal("compositeTranscodingBitrate", 500);
      const fps = intVal("compositeTranscodingFps", 15);
      const mixedVideoLayout = intVal("compositeTranscodingLayout", 0);
      const accessKey = document.getElementById("compositeAccessKey").value.trim();
      const secretKey = document.getElementById("compositeSecretKey").value.trim();
      const vendor = intVal("compositeVendor", 1);
      const region = intVal("compositeRegion", 0);
      const bucket = document.getElementById("compositeBucket").value.trim();
      const fileNamePrefix = arrayVal("compositeFileNamePrefix");

      if (!accessKey || !secretKey || !bucket) {
        document.getElementById("response").textContent = "Error: Storage Access Key, Secret Key, and Bucket are required.";
        return null;
      }

      const request = {
        cname,
        uid,
        clientRequest: {
          token: token || "",
          recordingConfig: {
            maxIdleTime,
            streamTypes,
            audioProfile,
            channelType,
            videoStreamType,
            transcodingConfig: {
              width,
              height,
              bitrate,
              fps,
              mixedVideoLayout
            },
            subscribeVideoUids,
            unsubscribeVideoUids,
            subscribeAudioUids,
            unsubscribeAudioUids,
            subscribeUidGroup,
            // composite extensionParam
            extensionParams: {
              enableLivePlaylist: true
            }
          },
          storageConfig: {
            accessKey,
            secretKey,
            region,
            vendor,
            bucket,
            fileNamePrefix
          }
        }
      };

      if (shouldIncludeMp4()) {
        request.clientRequest.recordingFileConfig = { avFileType: ["hls", "mp4"] };
      }
      return request;
    }

    function buildStartBodyIndividual() {
      const cname = document.getElementById("cname").value.trim();
      const uid = document.getElementById("uid").value.trim();
      const token = document.getElementById("token").value.trim();
      const maxIdleTime = intVal("individualMaxIdleTime", 30);
      const streamTypes = intVal("individualStreamTypes", 2);
      const subscribeVideoUids = arrayVal("individualSubscribeVideoUids");
      const unsubscribeVideoUids = arrayVal("individualUnsubscribeVideoUids");
      const subscribeAudioUids = arrayVal("individualSubscribeAudioUids");
      const unsubscribeAudioUids = arrayVal("individualUnsubscribeAudioUids");
      const subscribeUidGroup = intVal("individualSubscribeUidGroup", 0);
      const channelType = intVal("individualChannelType", 0);
      const videoStreamType = intVal("individualVideoStreamType", 0);
      const accessKey = document.getElementById("individualAccessKey").value.trim();
      const secretKey = document.getElementById("individualSecretKey").value.trim();
      const vendor = intVal("individualVendor", 1);
      const region = intVal("individualRegion", 0);
      const bucket = document.getElementById("individualBucket").value.trim();
      const fileNamePrefix = arrayVal("individualFileNamePrefix");

      if (!accessKey || !secretKey || !bucket) {
        document.getElementById("response").textContent = "Error: Storage Access Key, Secret Key, and Bucket are required.";
        return null;
      }

      const request = {
        cname,
        uid,
        clientRequest: {
          token: token || "",
          recordingConfig: {
            maxIdleTime,
            streamTypes,
            channelType,
            videoStreamType,
            subscribeVideoUids,
            unsubscribeVideoUids,
            subscribeAudioUids,
            unsubscribeAudioUids,
            subscribeUidGroup
          },
          storageConfig: {
            accessKey,
            secretKey,
            region,
            vendor,
            bucket,
            fileNamePrefix
          }
        }
      };

      if (shouldIncludeMp4()) {
        request.clientRequest.recordingFileConfig = { avFileType: ["hls", "mp4"] };
      }
      return request;
    }

    function buildStartBodyWeb() {
      const cname = document.getElementById("cname").value.trim();
      const uid = document.getElementById("uid").value.trim();
      const token = document.getElementById("token").value.trim();
      const webUrl = document.getElementById("webUrl").value.trim();
      const maxRecordingHour = intVal("webMaxRecordingHour", 3);
      const audioProfile = intVal("webAudioProfile", 0);
      const videoWidth = intVal("webVideoWidth", 1280);
      const videoHeight = intVal("webVideoHeight", 720);
      const accessKey = document.getElementById("webAccessKey").value.trim();
      const secretKey = document.getElementById("webSecretKey").value.trim();
      const vendor = intVal("webVendor", 1);
      const region = intVal("webRegion", 0);
      const bucket = document.getElementById("webBucket").value.trim();
      const fileNamePrefix = arrayVal("webFileNamePrefix");

      if (!accessKey || !secretKey || !bucket) {
        document.getElementById("response").textContent = "Error: Storage Access Key, Secret Key, and Bucket are required.";
        return null;
      }

      const request = {
        cname,
        uid,
        clientRequest: {
          token: token || "",
          extensionServiceConfig: {
            errorHandlePolicy: "error_abort",
            extensionServices: [{
              serviceName: "web_recorder_service",
              errorHandlePolicy: "error_abort",
              serviceParam: {
                url: webUrl,
                audioProfile,
                videoWidth,
                videoHeight,
                maxRecordingHour
              }
            }]
          },
          storageConfig: {
            accessKey,
            secretKey,
            vendor,
            region,
            bucket,
            fileNamePrefix
          }
        }
      };

      if (shouldIncludeMp4()) {
        request.clientRequest.recordingFileConfig = { avFileType: ["hls", "mp4"] };
      }
      return request;
    }

    function buildStartRequestBody() {
      if (globalMode === "composite") return buildStartBodyComposite();
      if (globalMode === "individual") return buildStartBodyIndividual();
      if (globalMode === "web") return buildStartBodyWeb();
      return {};
    }

    async function startRecording() {
      const responseEl = document.getElementById("response");
      responseEl.textContent = "Starting recording...";
      const appid = document.getElementById("appid").value.trim();
      if (!appid) {
        responseEl.textContent = "Error: App ID is required.";
        return;
      }
      if (!globalResourceId) {
        responseEl.textContent = "Error: resourceId is empty. Acquire first.";
        return;
      }
      if (!document.getElementById("cname").value.trim() || !document.getElementById("uid").value.trim()) {
        responseEl.textContent = "Error: Channel name and UID are required.";
        return;
      }
      animateCloud();
      const body = buildStartRequestBody();
      if (!body) return; 
      const urlMode = getUrlMode();
      const url = `https://api.agora.io/v1/apps/${appid}/cloud_recording/resourceid/${globalResourceId}/mode/${urlMode}/start`;
      try {
        const resp = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json", "Authorization": getAuthHeaders() },
          body: JSON.stringify(body)
        });
        const data = await resp.json();
        globalSid = data.sid || "";
        document.getElementById("sid").value = globalSid;
        responseEl.textContent = JSON.stringify(data, null, 2);
      } catch (error) {
        responseEl.textContent = error.toString();
      }
    }

    function buildUpdateBodyCompositeOrIndividual(cname, uid, subVid, unsubVid, subAud, unsubAud) {
      return {
        cname,
        uid,
        clientRequest: {
          streamSubscribe: {
            audioUidList: { subscribeAudioUids: subAud, unsubscribeAudioUids: unsubAud },
            videoUidList: { subscribeVideoUids: subVid, unsubscribeVideoUids: unsubVid }
          }
        }
      };
    }

    function buildUpdateBody() {
      const cname = document.getElementById("cname").value.trim();
      const uid = document.getElementById("uid").value.trim();
      if (globalMode === "composite") {
        const subscribeVideoUids = arrayVal("compositeSubscribeVideoUids");
        const unsubscribeVideoUids = arrayVal("compositeUnsubscribeVideoUids");
        const subscribeAudioUids = arrayVal("compositeSubscribeAudioUids");
        const unsubscribeAudioUids = arrayVal("compositeUnsubscribeAudioUids");
        return buildUpdateBodyCompositeOrIndividual(cname, uid, subscribeVideoUids, unsubscribeVideoUids, subscribeAudioUids, unsubscribeAudioUids);
      }
      else if (globalMode === "individual") {
        const subscribeVideoUids = arrayVal("individualSubscribeVideoUids");
        const unsubscribeVideoUids = arrayVal("individualUnsubscribeVideoUids");
        const subscribeAudioUids = arrayVal("individualSubscribeAudioUids");
        const unsubscribeAudioUids = arrayVal("individualUnsubscribeAudioUids");
        return buildUpdateBodyCompositeOrIndividual(cname, uid, subscribeVideoUids, unsubscribeVideoUids, subscribeAudioUids, unsubscribeAudioUids);
      }
      else if (globalMode === "web") {
        const webOnHold = document.getElementById("webOnHoldCheckbox").checked;
        return {
          cname,
          uid,
          clientRequest: { webRecordingConfig: { onhold: webOnHold } }
        };
      }
      return { cname, uid, clientRequest: {} };
    }

    async function updateRecording() {
      const responseEl = document.getElementById("response");
      responseEl.textContent = "Updating recording...";
      const appid = document.getElementById("appid").value.trim();
      const { resourceId, sid } = getActiveResourceAndSid();
      if (!resourceId || !sid) {
        responseEl.textContent = "Error: resourceId or sid is empty. Start a recording first.";
        return;
      }
      const body = buildUpdateBody();
      const urlMode = getUrlMode();
      const url = `https://api.agora.io/v1/apps/${appid}/cloud_recording/resourceid/${resourceId}/sid/${sid}/mode/${urlMode}/update`;
      try {
        const resp = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json", "Authorization": getAuthHeaders() },
          body: JSON.stringify(body)
        });
        const data = await resp.json();
        responseEl.textContent = JSON.stringify(data, null, 2);
      } catch (error) {
        responseEl.textContent = error.toString();
      }
    }

    /* ---------------- STOP ---------------- */
    async function stopRecording() {
      const responseEl = document.getElementById("response");
      responseEl.textContent = "Stopping recording...";
      const cname = document.getElementById("cname").value.trim();
      const uid = document.getElementById("uid").value.trim();
      const appid = document.getElementById("appid").value.trim();
      const { resourceId, sid } = getActiveResourceAndSid();
      if (!resourceId || !sid) {
        responseEl.textContent = "Error: resourceId or sid is empty. Start a recording first.";
        return;
      }
      const urlMode = getUrlMode();
      const url = `https://api.agora.io/v1/apps/${appid}/cloud_recording/resourceid/${resourceId}/sid/${sid}/mode/${urlMode}/stop`;
      const body = { cname, uid, clientRequest: {} };
      try {
        const resp = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json", "Authorization": getAuthHeaders() },
          body: JSON.stringify(body)
        });
        const data = await resp.json();
        responseEl.textContent = JSON.stringify(data, null, 2);

        // If we're including MP4, parse the file list, pick the .mp4 to auto-play
        if (shouldIncludeMp4() && data.serverResponse && Array.isArray(data.serverResponse.fileList)) {
          let m3u8File = null;
          let mp4File = null;

          for (const f of data.serverResponse.fileList) {
            if (f.fileName.endsWith(".m3u8")) {
              m3u8File = f.fileName;
            } else if (f.fileName.endsWith(".mp4")) {
              mp4File = f.fileName;
            }
          }

          if (mp4File) {
            globalFileName = mp4File;
            const mp4Url = generatePublicURL();
            if (document.getElementById("playLiveVideoCheckbox").checked && mp4Url) {
              const videoPlayer = document.getElementById("videoPlayer");
              handleVideoPlayback(mp4Url, videoPlayer);
              document.getElementById("publicUrlInput").value = mp4Url;
              document.getElementById("videoPlayerContainer").classList.remove("hidden");
            }
          }

          // Show a "Copy M3U8 link" button if we have it
          if (m3u8File) {
            const m3u8Url = generateUrlForFileName(m3u8File);
            currentM3u8Url = m3u8Url;
            // Show the button next to the Public URL input
            document.getElementById("copyM3u8LinkBtn").classList.remove("hidden");
          } else {
            // Hide the button if no .m3u8
            document.getElementById("copyM3u8LinkBtn").classList.add("hidden");
            currentM3u8Url = "";
          }
        }
      } catch (error) {
        responseEl.textContent = error.toString();
      }
    }

    // Helper to generate a URL for a custom filename
    function generateUrlForFileName(fileName) {
      const { bucket, vendor, region } = getStorageConfigForCurrentMode();
      const regionText = getRegionText(vendor, region);
      let url = "";
      switch(vendor) {
        case 1:
          url = `https://${bucket}.s3.${normalizeRegion(regionText)}.amazonaws.com/${fileName}`;
          break;
        case 2:
          url = `https://${bucket}.oss-${normalizeRegion(regionText)}.aliyuncs.com/${fileName}`;
          break;
        case 3:
          url = `https://${bucket}.cos.${normalizeRegion(regionText)}.myqcloud.com/${fileName}`;
          break;
        case 5:
          url = `https://${bucket}.blob.core.windows.net/${fileName}`;
          break;
        case 6:
          url = `https://storage.googleapis.com/${bucket}/${fileName}`;
          break;
        case 7:
          url = `https://${bucket}.obs.${normalizeRegion(regionText)}.myhuaweicloud.com/${fileName}`;
          break;
        case 8:
          url = `https://${bucket}.bcebos.com/${fileName}`;
          break;
        default:
          url = "";
      }
      return url;
    }

    let lastM3u8Url = "";
    let m3u8NeedsRecheck = false;
    var globalExists = false;

    async function checkM3U8Exists(url) {
        try {
            const response = await fetch(url, { method: "HEAD" });
            globalExists = true;
            return response.status === 200;
        } catch {
            globalExists = false;
            return false;
        }
        }
    
    /* ---------------- QUERY with AUTO-REFRESH ---------------- */
    async function queryRecording() {
        animateCloud();
        const queryResultEl = document.getElementById("queryResult");
        const appid = document.getElementById("appid").value.trim();

        // Either use manual ResourceId / SID fields, or your globalResourceId / globalSid:
        const resourceId = document.getElementById("resourceId").value.trim() || globalResourceId;
        const sid = document.getElementById("sid").value.trim() || globalSid;
        if (!resourceId || !sid) {
            queryResultEl.textContent = "Error: resourceId or sid is empty.";
            stopAutoQuery();
            return;
        }

        if (document.hidden) {
            // (Optional) Skip queries when the tab is not visible
            return;
        }

        queryResultEl.textContent = "Querying recording...";
        const urlMode = getUrlMode(); // "mix" for composite, or "web"/"individual" otherwise
        const queryUrl = `https://api.agora.io/v1/apps/${appid}/cloud_recording/resourceid/${resourceId}/sid/${sid}/mode/${urlMode}/query`;

        try {
            const resp = await fetch(queryUrl, {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Authorization": getAuthHeaders()
            }
            });
            const data = await resp.json();
            queryResultEl.textContent = JSON.stringify(data, null, 2);

            const serverFileList = data.serverResponse?.fileList;
            if (!Array.isArray(serverFileList) || serverFileList.length === 0) {
            // No file in the response yet
            return;
            }
            const serverName = serverFileList[0]?.fileName || "";
            if (!serverName) return;

            // If we've *already* found a playable URL (got 200), do nothing more:
            if (hasFoundPlayableUrl) {
            // We won't keep re-checking HEAD or rewriting the player source
            return;
            }

            // ---- We haven't found a playable file yet, so do rename (if composite) + HEAD check ----

            // If it's the *first time* we see this serverName, or if you want to handle "new" files:
            if (serverName !== lastQueriedFileName) {
            lastQueriedFileName = serverName;

            // If composite + .m3u8 => rename once; else just keep the original name
            if (globalMode === "composite" && serverName.endsWith(".m3u8")) {
                const { fileNamePrefix } = getStorageConfigForCurrentMode();
                lastPlayableName = renameM3u8ForComposite(serverName, !!fileNamePrefix);
            } else {
                lastPlayableName = serverName;
            }
            }
            
            // Generate the public URL for *lastPlayableName* (which might have the "live_" prefix in composite mode)
            const publicURL = generateUrlForFileName(lastPlayableName);

            // Optionally: show it to the user even if it doesnt exist yet
            document.getElementById("publicUrlInput").value = publicURL;
            console.log("publicUrlInput: " + publicUrlInput.value);

            // HEAD check to see if the file is actually present
            const exists = await checkM3U8Exists(publicURL);
            if (exists) {
            // Once we get 200, we mark that we found our playable file:
            hasFoundPlayableUrl = true;

            // If user wants to play live video, do it now:
            if (document.getElementById("playLiveVideoCheckbox").checked) {
                const videoPlayer = document.getElementById("videoPlayer");
                handleVideoPlayback(publicURL, videoPlayer);
                document.getElementById("videoPlayerContainer").classList.remove("hidden");
            }
            } else {
            console.log("File not yet available at:", publicURL);
            // Next queryRecording() call (in ~10s) will HEAD-check again
            }

        } catch (error) {
            queryResultEl.textContent = error.toString();
        }
        }
    function startAutoQuery() {
      stopAutoQuery();
      isAutoQueryActive = true;
      queryRecording();
      queryIntervalId = setInterval(() => {
        if (isAutoQueryActive) queryRecording();
      }, 10000);
    }

    function stopAutoQuery() {
      isAutoQueryActive = false;
      if (queryIntervalId) {
        clearInterval(queryIntervalId);
        queryIntervalId = null;
      }
    }

    /* ---------------- BUTTON HANDLERS ---------------- */
    function onAcquireClick() {
      stopAutoQuery();
      acquireRecording();
    }
    function onStartClick() {
      stopAutoQuery();
      hasFoundPlayableUrl = false;
      lastQueriedFileName = "";
      lastPlayableName = "";
      globalFileName = "";
      startRecording();
    }
    function onUpdateClick() {
      stopAutoQuery();
      updateRecording();
    }
    function onStopClick() {
      stopAutoQuery();
      stopRecording();
    }
    function onQueryClick() {
      startAutoQuery();
    }

    /* ---------------- COPY REQUEST BODY BUTTONS ---------------- */
    function copyStartRequestBody() {
      const body = buildStartRequestBody();
      if (!body) {
        alert("Start request body is invalid or missing required fields.");
        return;
      }
      const bodyString = JSON.stringify(body, null, 2);
      navigator.clipboard.writeText(bodyString).then(() => {
        alert("Start request body copied to clipboard!");
      }).catch(err => {
        alert("Failed to copy: " + err);
      });
    }

    function copyUpdateRequestBody() {
      const body = buildUpdateBody();
      if (!body) {
        alert("Update request body is invalid or missing required fields.");
        return;
      }
      const bodyString = JSON.stringify(body, null, 2);
      navigator.clipboard.writeText(bodyString).then(() => {
        alert("Update request body copied to clipboard!");
      }).catch(err => {
        alert("Failed to copy: " + err);
      });
    }

    /* ---------------- CLOUD ANIMATION FUNCTION ---------------- */
    function animateCloud() {
      const cloud = document.createElement('div');
      cloud.classList.add('cloud-animation');
      cloud.innerHTML = `
    <svg width="400" height="300" viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="cloudGradient" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0%" stop-color="#B3E5FC"/>
          <stop offset="100%" stop-color="#81D4FA"/>
        </linearGradient>
      </defs>
      <g>
        <ellipse cx="150" cy="150" rx="50" ry="35" fill="url(#cloudGradient)" />
        <ellipse cx="210" cy="130" rx="45" ry="30" fill="url(#cloudGradient)" />
        <ellipse cx="270" cy="150" rx="50" ry="35" fill="url(#cloudGradient)" />
        <ellipse cx="210" cy="170" rx="60" ry="40" fill="url(#cloudGradient)" />
        <text x="210" y="155" text-anchor="middle" fill="#fff" font-size="30" font-family="Arial" dy=".3em">
          Agora
        </text>
      </g>
    </svg>
  `;
      document.body.appendChild(cloud);
      cloud.addEventListener('animationend', () => {
        cloud.remove();
      });
    }
  </script>
  <a
  href="https://github.com/frank005/cloud_record_console"
  target="_blank"
  rel="noopener noreferrer"
  class="fixed top-4 right-4 w-10 h-10 bg-gray-800 flex items-center justify-center rounded-full shadow-lg hover:bg-gray-700 transition"
  title="View my GitHub"
  >
  <!-- Inline SVG for GitHub icon -->
  <svg
    class="w-5 h-5 text-white"
    fill="currentColor"
    viewBox="0 0 24 24"
    aria-hidden="true"
  >
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M12 .296a12 12 0 00-3.797 23.389c.6.111.82-.261.82-.58v-2.259c-3.338.725-4.042-1.61-4.042-1.61-.547-1.39-1.336-1.76-1.336-1.76-1.09-.746.082-.73.082-.73 1.205.084 1.84 1.237 1.84 1.237 1.07 1.835 2.807 1.305 3.492.998.107-.776.42-1.305.764-1.604-2.665-.305-5.467-1.333-5.467-5.93 0-1.31.469-2.381 1.24-3.221-.125-.303-.54-1.52.117-3.165 0 0 1.012-.324 3.317 1.23.96-.267 1.987-.399 3.009-.404 1.02.005 2.049.137 3.01.404 2.304-1.554 3.315-1.23 3.315-1.23.659 1.646.244 2.863.12 3.166.772.84 1.24 1.91 1.24 3.22 0 4.61-2.807 5.623-5.48 5.92.431.372.817 1.104.817 2.224v3.293c0 .319.218.694.824.576A12 12 0 0012 .296z"
    ></path>
  </svg>
  </a>
</body>
</html>